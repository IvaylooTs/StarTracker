- [x]  integration!
- [ ] Find if quaternions are correct
- [x] Run IMU correctly again

Q1 of day - come here, need to continue working on the circuit design, Let Ivo do it for me, while i started integration on the lost in space and get the image from the IMU
Q2 of day - started working on integartion. 1-2 hours of fixing websockets problems, i made the pi take a image from the screen, then read it and check lost i nsapce

After I test it with sample image capture I modified the script to run and save the located stars locally and test the script.

made a small test bench with Ivo's PC and monitor, then integrated the raspberry and run the script. 

After some movement and placement of the raspberry PI we got the correct values for the hips of the stars, checked them and it works.

after that we ran the same test from the same place and it worked again! I cannot believe this! now i wonder what is going to go wrong. We need to do so many tests, be we have only around 13 days left.




### 1. Prepare your data

Make sure you have two matching lists of **unit vectors** (numpy arrays):

```
import numpy as np

# Reference vectors from star database (shape: N x 3)
V = np.array([
    [x1, y1, z1],
    [x2, y2, z2],
    ...
])

# Measured vectors from your sensor (shape: N x 3)
W = np.array([
    [x1', y1', z1'],
    [x2', y2', z2'],
    ...
])

```
### 2. Compute matrix B
```
B = W.T @ V  # shape: (3, 3)

```
### 3. SVD of B

`U, S, Vt = np.linalg.svd(B)`

### 4. Compute rotation matrix
`R = U @ np.diag([1, 1, np.linalg.det(U @ Vt)]) @ Vt`
### ### 5. Use the rotation

Now you can rotate any vector from the reference frame into your sensor frame:
```
v = np.array([x, y, z])  # from database
w_estimated = R @ v      # should match your measurement
```