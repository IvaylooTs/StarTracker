
12:30 Lecture was canceled 
12:35 Simo said I need to check general stuff for the video capture of the chamber and give him feedback as soon as possible


- [x] Graph the data from the IMU
- [x] Fix the weird jumps in rotation of quaternions
- [x] Backup newest code to github raspberry pi code and website
- [x] Temperature display

### day before
Some important things for data from IMU:
- normalization of quaternions - correct math (not entering the 4d dimention, a.k.a. scaling)
- SLERP - smooth transition between data (no sudden jumps)
- Noise Clamping - if the change is too small ignores it

Possible problems for Noise Clamping - I think, if threshold is too big, small drift can accumulate over time. This needs verification. 


Concept to check for nomralization of quaternion:
```python
import numpy as np
from scipy.spatial.transform import Rotation as R

def normalize_quaternion(q):
    return q / np.linalg.norm(q)

def ensure_hemisphere(q1, q2):
    """Ensure q2 is in the same hemisphere as q1."""
    if np.dot(q1, q2) < 0:
        return -q2
    return q2

def slerp(q1, q2, t):
    """Spherical linear interpolation between q1 and q2."""
    r1 = R.from_quat(q1)
    r2 = R.from_quat(q2)
    return R.slerp(0, 1, [r1, r2])(t).as_quat()

# Example usage
q_prev = normalize_quaternion(np.array([0.0, 0.0, 0.0, 1.0]))  # previous quaternion
q_current = normalize_quaternion(np.array([0.0, 1.0, 0.0, 0.0]))  # current quaternion

q_current = ensure_hemisphere(q_prev, q_current)
q_smoothed = slerp(q_prev, q_current, t=0.5)  # interpolate halfway

print("Smoothed Quaternion:", q_smoothed)

```


---

### Jump filter
Random sudden jumps were fix using this threshold to ignore based on dot product greater than specific threshold. 
- this required high frequency data rate from IMU to main computer 

```python
LastQuaternion =(1, 0, 0, 0) # used for gitter cleanup
def DetectJitter(quaternion, threshold=0.25):
	global LastQuaternion
	if LastQuaternion == (1, 0, 0, 0):
		LastQuaternion = quaternion
		return quaternion
	else:
		diff = math.sqrt((LastQuaternion[0] - quaternion[0])**2 +
		(LastQuaternion[1] - quaternion[1])**2 +
		(LastQuaternion[2] - quaternion[2])**2 +
		(LastQuaternion[3] - quaternion[3])**2)
	if diff > threshold: # threshold for jitter detection
		print("Jitter detected, returning last quaternion. Difference:", diff)
		return LastQuaternion
	else:
		LastQuaternion = quaternion
		return quaternion
```

Quaternion jump/flip detection is easily seen in the graph:
![[Screenshot From 2025-07-30 15-38-25.png]]
The code above fixes this problem, but brings new thing.
Do you have a speed from sensor to recalculate the rotation fast enough? if I rotate the IMU fast enough, will it glitch?
- solution - If more than 5-15 checks are found that the quaternion is out of scope because of jump, it is probably not a glitch, but a fast flip in space and should be reconfigured, probably enter a **Infinite spin warning** to warn the satellite to slow down rotation. (problem found during release)

## software redundancy
In case of system failure of hardware components, there should be custom software implementation to handle the data and continue calculations with damaged systems.

If gyroscopes, Accelerometer, magnetometer or sensor fusion chip breaks, we need backup software to continue the operation of the systems. 

Development of this systems require mathematical functions to neglect error accumulation and configure the system for sensor-damage mode

##### Sensor damage modes:
1. one system damaged
	- Gyroscope - you can use magnetometer to get general direction, but very limited rotation
	- Accelerometer - unprocised gyroscope, lost of general movement and drift accumulation
	- Magnetometer - lost of heading, drift accumulation, Kelman filter fix
	- Sensor fusion chip - best case, continue calculations on raspberry pi, no further notice
2. two system damaged
	- only magnetometer - general idea of direction thanks to magnetometer
	- only accelerometer - maybe possible orientation to relative position, could work with known current rotation, but probably use complex algorithms
	- only gyroscope - could remain in relative rotation, possible big drift problems in just 10-15 seconds
3. three damaged systems
	- .... damn. Basically nothing can do.


- accelerometer to rotation - https://stackoverflow.com/questions/3755059/3d-accelerometer-calculate-the-orientation

##### Boot sequence:
1. Load normal operational mode
2. Check for init error
3. Check for calibration error
4. Check if all system work correct
5. Establish correction mode
	1. No errors - continue in standard mode, no magnetic recalibration 
	2. Errors in sensors - Restart sensors
	3. Continues error - Enter "sensor failure mode"

##### Ideas for error checks
| Address check               | Possible error                            | State                             |
| --------------------------- | ----------------------------------------- | --------------------------------- |
| **Self-test result (0x36)** | Checks BNO055's internal self-test result | Pass/fail per sensor              |
| **System status (0x39)**    | Detects if system error occurred          | 0x01 = error                      |
| **System error (0x3A)**     | Identifies if gyro failed to initialize   | 0x06 = gyro failure               |
| **Live data checks**        | Detects runtime anomalies                 | Use zero/static/outlier detection |

##### Software reset sudo code
1. mode reset - change the modes and reload 
2. trigger software reset and recalibration in register
```python
BNO055_SYS_TRIGGER = 0x3F
BNO055_OPR_MODE    = 0x3D
CONFIGMODE         =  0x00

# Put BNO055 into config mode first
writeRegister(BNO055_OPR_MODE, CONFIGMODE);
delay(25);

# Issue software reset
writeRegister(BNO055_SYS_TRIGGER, 0x20);
delay(650);  # Wait for reset to complete

# Reinitialize sensor mode/settings here
#  .....
```
(You can poll **`0x00` (CHIP_ID)** after resetâ€”it should read `0xA0`. This helps confirm that the BNO055 is responding again.)
3. Power resistor that can shut down power directly