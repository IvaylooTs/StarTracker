### todo:
- [x] Display video feed
- [x] Add 2 way communication
- [x] Add calibration buttons
- [x] Make calibration work
- [x] Make it so you can take and download pictures from the raspberry Pi
- [ ] Calibrate Camera
- [ ] Research communication link with Arduino via protocols like space-wire 
- additional: files are separated to keep things organized 


Problem with transferring the video to another web page some kind of "SSL problem" so i used custom SSL certificate to provide video, from the IP of the raspberry pi to html page on the laptop.
this worked
```bash
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
```

Camera access is very easy. Just use this html line:
```html
<img id="stream" src="https://192.168.55.160:5000/video_feed" alt="Live Stream" width="640">
```


You run ssl on the raspberry pi via:
```python
app.run(host='192.168.55.160', port=5000, ssl_context=('cert.pem', 'key.pem'))
```

#### Threading issue
transfering images and data requires 2 channels:
1.  flask server (port 5000) for image sending
2. websocket (port 6789) for quaternion data
The threading issue was fixed with this command:
```python
flask_thread = threading.Thread(target=run_flask)
flask_thread.daemon = True # Ensure thread exits when main program exits
flask_thread.start()
asyncio.run(main())
```


#### Weird bug?
When sending the quaternion data, we get non-normalized vector, which can be seen as weird distortion of the representation of Three.js. This is probably on the raspberry pi, but the bug wasn't tracked. 
The bug is only visual problem. Easy fix - normalize your data or remove it.


## Current UI progress

![[Screenshot 2025-07-29 at 13-58-42 Three.js Cube with Arrow.png]]



### Library problems and the raw I2C fix - few days ago
Due to the library being shit, the communication is done directly over I2C, ignoring any library we have.

We use `NDOF_FMC_OFF_MODE`, to stop the auto calibration of the *heading*. This allows us to remember the last location and stop auto calibration. Then we can do auto calibration in software.

Sensor connection settings:
```python
ADDR = 0x28 # Or 0x29 depending on BNO055 ADR pin
BUS = 1
```
Specific bits for modes:
```python
OPR_MODE_ADDR = 0x3D
CALIB_STAT = 0x35
CALIBRATION_REG_START = 0x55
CALIBRATION_REG_LEN = 22
CONFIG_MODE = 0x00
NDOF_FMC_OFF_MODE = 0x0C
```
Accessing data of calibration registers:
```python
calib = bus.read_byte_data(ADDR, CALIB_STAT)
sys = (calib >> 6) & 0x03
gyro = (calib >> 4) & 0x03
accel = (calib >> 2) & 0x03
mag = calib & 0x03
```
Euler angles addresses:
```python 
EULER_H_LSB = 0x1A
EULER_R_LSB = 0x1C
EULER_P_LSB = 0x1E
data = bus.read_i2c_block_data(ADDR, EULER_H_LSB, 6) # 2 bytes each for heading, roll, pitch
#convert from little endian signed 16-bit
heading = int.from_bytes(data[0:2], byteorder='little', signed=True) / 16.0
roll = int.from_bytes(data[2:4], byteorder='little', signed=True) / 16.0
pitch = int.from_bytes(data[4:6], byteorder='little', signed=True) / 16.0
```
Quaternion angels addresses:
```python
QUATERNION_REG_START = 0x20
data = bus.read_i2c_block_data(ADDR, QUATERNION_REG_START, 8)
# Convert bytes to 16-bit signed integers
w = int.from_bytes(data[0:2], byteorder='little', signed=True) / (1 << 14)
x = int.from_bytes(data[2:4], byteorder='little', signed=True) / (1 << 14)
y = int.from_bytes(data[4:6], byteorder='little', signed=True) / (1 << 14)
z = int.from_bytes(data[6:8], byteorder='little', signed=True) / (1 << 14)
```


#### Other developments
- Buttons were added for easy control
- Added better text in ssh terminal for better readability when program is looked at

### The normalization problem
Right now the vector is not normalized when calibrated, this can cause a lot of issues. Problem is probably we enter the 4D dimension and lose consistency in scale 

###  The problem where the sd card died
Now i need to download everything

Recovery took from 18:50 to 21:36 (2:30 hours)

Image of the sd card should be made to stop this from happening
Thankfully we had all the scripts on one hand and little damage was done to the actual code

Actually even the quaternion calibration was saved.
Thanks to *vs code* the tabs stored the information from the raspberry pi, and 80 % of the things were extracted from there. The other 20% was simple copy paste

Downloading the libraries took a lot of time. Needed to re-flash once of some problem in apt store and was faster to do this, than search how to fix it, clean up and download all again. 


Restored to this state:
![[Pasted image 20250729213933.png]]