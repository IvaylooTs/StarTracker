import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# ==============================================================================
# --- CONFIGURATION ---
# ==============================================================================
# The path to the results file generated by your run_batch.py script.
# UPDATE THIS PATH if your results file is named something different.
RESULTS_FILE_PATH = "results.txt"
# ==============================================================================

def read_quaternions_from_file(filepath: str) -> list:
    """
    Reads a results.txt file in the format 'imagename;w;x;y;z;time',
    parses each line, and extracts the successful quaternion data.
    """
    parsed_quaternions = []
    print(f"Reading quaternions from: {filepath}")
    
    try:
        with open(filepath, 'r') as f:
            for line in f:
                # Skip any empty lines or headers
                if not line.strip() or line.startswith('---') or line.startswith('ImageName'):
                    continue
                
                parts = line.strip().split(';')
                
                # Check for a valid, successful line which should have 6 parts.
                # This automatically filters out lines with "FAILED".
                if len(parts) == 6:
                    try:
                        # The quaternion components are now in parts 1, 2, 3, and 4.
                        w = float(parts[1])
                        x = float(parts[2])
                        y = float(parts[3])
                        z = float(parts[4])
                        parsed_quaternions.append((w, x, y, z))
                    except ValueError:
                        # This will catch any line that has 6 parts but contains non-numeric data.
                        print(f"Warning: Could not parse coordinates in line: '{line.strip()}'")
                            
    except FileNotFoundError:
        print(f"!!! ERROR: The results file was not found at '{filepath}'")
        
    return parsed_quaternions

def quat_to_matrix(q: tuple) -> np.ndarray:
    """Convert quaternion (w, x, y, z) to a 3x3 rotation matrix."""
    w, x, y, z = q
    return np.array([
        [1 - 2*(y*y + z*z), 2*(x*y - z*w),     2*(x*z + y*w)],
        [2*(x*y + z*w),     1 - 2*(x*x + z*z), 2*(y*z - x*w)],
        [2*(x*z - y*w),     2*(y*z + x*w),     1 - 2*(x*x + y*y)]
    ])

# --- Main script execution ---

# 1. Load the quaternions from the file using the corrected parser
quaternions = read_quaternions_from_file(RESULTS_FILE_PATH)

if not quaternions:
    print("No valid quaternions were found to visualize.")
else:
    print(f"Successfully loaded {len(quaternions)} quaternions for visualization.")

    # 2. Create 3D plot
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')

    # Original vector representing the camera's line of sight (Z-axis)
    v = np.array([0, 0, 1]) 

    # 3. Draw each quaternion's rotated vector as an arrow
    for i, q in enumerate(quaternions):
        R = quat_to_matrix(q)
        rotated_vec = R @ v
        
        # Draw the arrow representing the camera's pointing direction
        ax.quiver(0, 0, 0, rotated_vec[0], rotated_vec[1], rotated_vec[2],
                  length=1.0, normalize=True, color=plt.cm.viridis(i / len(quaternions)),
                  arrow_length_ratio=0.1)
        
        # Add a label to the tip of the arrow
        # ax.text(rotated_vec[0]*1.1, rotated_vec[1]*1.1, rotated_vec[2]*1.1, f"Q{i+1}",
        #         color='black', fontsize=8)

    # 4. Set axis properties for a clean look
    ax.set_xlim([-1, 1])
    ax.set_ylim([-1, 1])
    ax.set_zlim([-1, 1])
    ax.set_xlabel('X-axis')
    ax.set_ylabel('Y-axis')
    ax.set_zlabel('Z-axis')
    ax.set_title('Visualization of Camera Attitude from Batch Results')
    ax.view_init(elev=20, azim=30)
    ax.grid(True)
    
    # 5. Show the plot
    plt.show()